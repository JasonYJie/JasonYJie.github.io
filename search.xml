<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F03%2F10%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[01分数规划学习笔记]]></title>
    <url>%2F2018%2F12%2F03%2F01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题 有 \(n\) 个物品，每个物品有两个属性 \(a_i\) 和 \(b_i\)，需要选出 \(k\) 个，设选出的编号集合是 \(S\) 最大化 \[\frac{\sum_{i\in S} a_i}{\sum_{i\in S} b_i}\] 保留一定精度 二分 这个问题是可以二分的，考虑二分一个答案 \(ans\)，条件是 \[\frac{\sum_{i\in S} a_i}{\sum_{i\in S} b_i} \ge ans\] 可以转化为 \[\sum_{i\in S} a_i-ans \sum_{i\in S} b_i \ge 0\] 这样只需要按照 \(a_i-ans*b_i\) 排序取最大的 \(k\) 个判断即可 直接使用 sort()，令 \(w\) 表示 \(\frac{\text{值域}}{\text{精度}}\)，复杂度 \(\mathcal O(n\log n\log w)\) 用 nth_element()，复杂度 \(\mathcal O(n\log w)\) 问题有其他变种，大概挺simple，二分基本上就好了 迭代 我不知道这复杂度对不对，好像正确性也不知道，反正跑得快 先令 \(ans=0\)，每次用相同的方法，可以求出一个 \(\frac{\sum_{i\in S} a_i}{\sum_{i\in S} b_i}\)，显然这也是一个合法的答案，并且肯定更优。 一直迭代直到增加量很小时结束 例题 LOJ #149. 01分数规划 模板 迭代目前跑得最快 二分的代码的写法大概是因为寻址不连续，没有写struct一起nth_element()快 代码 二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() &#123; static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);&#125;template&lt;class T&gt;inline void read(T &amp;x) &#123; static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) &#123; if (c == '-') iosig=true; if (c == -1) return; &#125; for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;&#125;const int N = 100005;int n, k, a[N], b[N], g[N];double f[N];inline bool cmp(int x, int y)&#123; return f[x]&gt;f[y];&#125;inline double check(double x)&#123; for(int i=1; i&lt;=n; ++i) f[i]=a[i]-b[i]*x, g[i]=i; nth_element(g+1, g+k+1, g+n+1, cmp); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[g[i]], sb+=b[g[i]]; return (double)sa/sb;&#125;int main() &#123; read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i]); for(int i=1; i&lt;=n; ++i) read(b[i]); double l=0, r=1e6, ans=0; while(r-l&gt;1e-7)&#123; double mid=(l+r)/2; if(check(mid)&gt;=mid) ans=mid, l=mid; else r=mid; &#125; return printf("%.4f", ans), 0;&#125; 迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;#define ll long longinline char read() &#123; static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);&#125;template&lt;class T&gt;inline void read(T &amp;x) &#123; static bool iosig; static char c; for (iosig=false, c=read(); !isdigit(c); c=read()) &#123; if (c == '-') iosig=true; if (c == -1) return; &#125; for (x=0; isdigit(c); c=read()) x=((x+(x&lt;&lt;2))&lt;&lt;1)+(c^'0'); if (iosig) x=-x;&#125;const int N = 100005;int n, k;struct item&#123; int a, b; double f; inline bool operator &lt;(const item &amp;rhs)const&#123; return f&gt;rhs.f;&#125;&#125; a[N];inline double check(double x)&#123; for(int i=1; i&lt;=n; ++i) a[i].f=a[i].a-a[i].b*x; nth_element(a+1, a+k+1, a+n+1); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[i].a, sb+=a[i].b; return (double)sa/sb;&#125;int main() &#123; read(n), read(k); for(int i=1; i&lt;=n; ++i) read(a[i].a); for(int i=1; i&lt;=n; ++i) read(a[i].b); ll sa=0, sb=0; for(int i=1; i&lt;=k; ++i) sa+=a[i].a, sb+=a[i].b; double ans=(double)sa/sb, last; do ans=check(last=ans); while(ans-last&gt;1e-6); return printf("%.4f", ans), 0;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>01分数规划</tag>
      </tags>
  </entry>
</search>
