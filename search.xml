<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces 977 A]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977a%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 A\) 题解： 977A 题意： 给定一个整数 \(n\) 然后给定一个操作次数 \(k\) ,要求输出最后根据操作的数字 操作如下： 当最后一位不为\(0\) 则减 \(1\) 否则除 \(10\) ​ 思考： 直接按照题意模拟就好了，没什么好说的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;ll n,k;int main()&#123; n=read(); k=read(); for(register int i=1;i&lt;=k;i++) &#123; if(n%10!=0) n--; else n/=10; &#125; printf("%lld\n",n); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 G]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978g%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 G\) 题解： 978G 题意： ​共有 \(n\) 天，\(m\) 场考试编号 \(1～m\) ，每场考试给出 \(s\) 题库发布的时间（即代表从此时起可以开始复习这门科目） \(d\) 这门科目考试的时间 \(t\) 需要复习的时间。 现在，每天你可以选择复习，或者休息，只能选其中一样！如果是考试的时间，则必须去考试！ 问，你是否可以复习完所有科目并通过考试 如果可以，输出安排表，\(1～m\) 代表复习功课，\(0\) 表示休息，\(m+1\) 表示考试。 如果不能，输出 \(-1\)。 ​ 思考： 显然是一道贪心，考试时间越早的我们要越早复习完。 所以开一个 \(struct\) 记录发布时间，考试时间，复习时间，和考试编号 然后对于一天我们就暴力去判断 考试的天必须考试 剩下的根据题目限制判断一下复习还是休息 最后，如果有的科目没有复习完则不合法，否则允许 注意：题目没有要求连续复习，所以允许隔天复习！！！ 不知道为什么我的代码吗\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a.b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 110using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,m,flag;structt st&#123; int id,s,e,t;&#125;a[N];int ans[N];inline bool cmp(st x,st y)&#123; return x.t&lt;y.t;&#125;int main()&#123; n=read(); m=read(); for(register int i=1;i&lt;=m;i++) &#123; a[i].id=i; a[i].s=read(); a[i].t=read(); a[i].e=read(); ans[a[i].t]=m+1; &#125; sort(a+1,a+m+1,cmp); for(register int i=1;i&lt;=n;i++) &#123; if(ans[i]) continue; flag=0; for(register int j=1;j&lt;=m;j++) &#123; if((a[j].e)&amp;&amp;(a[j].s&lt;=i)&amp;&amp;(a[j].t&gt;i)) &#123; ans[i]=a[j].id; a[j].e--; flag=1; &#125; if(flag) break; &#125; &#125; for(register int j=1;j&lt;=m;j++) if(a[j].e) &#123; puts("-1"); return 0; &#125; for(register int i=1;i&lt;=n;i++) printf("%d ",ans[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 C]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977c%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 C\) 题解： 977C 题意： 给你一个长度为 \(n\) 的整数序列和一个数 \(k\) 。 您应该在 \([1 , 1e9]\)（即 $1 x 1e9 $）的范围内输出任何整数 \(x\)，使得给定序列的 \(k\) 个元素恰好小于或等于x。 请注意，该序列可以包含相同的元素。 如果没有这样的\(x\)，则输出 \(“-1”\)（不含引号） ​ 思考： 直接进行排序，然后吧第 \(k\) 的元素输出 然后你就会发现 \(Wa\) 了 少了一种情况 如果 \(k==0\) 时，而当前 \(a_1\) 却等于 \(1\) 你会发现其实是没有数字满足要求的 所以还要特判一下 \(k==0\) 的情况就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 2000100using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,k;int a[N];int main()&#123; n=read(); k=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1); int tmp=a[k],sum=0; for(register int i=1;i&lt;=n;i++) if(tmp&gt;=a[i]) sum++; if(k==0) &#123; if(a[1]==1) puts("-1"); else printf("%d\n",a[1]-1); return 0; &#125; if(sum==k) printf("%d\n",tmp); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977d%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 D\) 题解： 977D 题意： 给你一个被打乱的序列，每次操作，都要把这个数除以 \(3\) 或者乘 \(2\) ， 使之变成下一个数，输出排序后满足条件的原序列数。 ​ 思考： 我们分析一下其实这个给定数组中的每一个数字都是 \(3\) 的幂次与 \(2\) 的幂次的加和 所以我们需要重新排序 第一关键词，首先按照一个数字能够整除 \(3\) 的次数，这显然是一个递减序列 如果次数相同时，那么只有乘 \(2\) 的变大操作 ，所以此时把较大的放到后面 就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 110using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n;ll a[N];inline ll get(ll x)&#123; ll cnt=0; while((x%3)==0) &#123; cnt++; x/=3; &#125; return cnt;&#125;inline bool cmp(ll x,ll y)&#123; ll tmp1,tmp2; tmp1=get(x); tmp2=get(y); if(tmp1==tmp2) return x&lt;y; return tmp1&gt;tmp2;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1,cmp); for(register int i=1;i&lt;=n;i++) printf("%lld ",a[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 F]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978F%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978F\) 题解： 978F 题意： ​ ​ 给出 \(n\) 个人的能力值，给出 \(m\) 对关系，如果一个人的能力值比另一个人的能力值高，并且他们两没有关系的话，那么，这个人就可以成为那个人的导师。求出每个人最多可以是几个人的导师。 ​ 思考： 开一个 \(struct\) 记录当前这个人的 位置、能力值、答案 然后按照能力值从小到大排序。排序之后按照二分出当前的能量值是第几大的能力值，更新答案。 处理关系，每次输进来，在较大的一个能力值中减掉一个就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,x,y,ans,w;int a[N],b[N];int main()&#123; n=read(); w=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),b[i]=b[i-1]+a[i]; sort(b+1,b+n+1); x=w-b[n];x=min(w,x); y=-b[1];y=max(0,y); if(x-y+1&lt;=0) puts("0"); else printf("%d\n",x-y+1); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 E]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978E%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978E\) 题解： 978E 题意： ​ ​ ​共 \(N\) 站，汽车每站变化 \(a_i\) 人。问刚开始汽车上人数有多少种可能？ ​ 思考： 因为是变化值，所以相当于差分了一下，先做一遍前缀和，变成每个车站当前有多少人。然后排序前缀和数组。\(- sum_1\) 就是最少的人数边界 \(w - sum_n\) 就是最多的人数边界 最 \(ans\) 就是两者相减 注意： 做处理的时候有可能是单调，也就是说一直下车或者一直上车 最小边界要做处理： \(minn=max(-sum_i , 0)\) 最大边界要做处理： \(maxn=minn(w,w-sum[n])\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,x,y,ans,w;int a[N],b[N];int main()&#123; n=read(); w=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),b[i]=b[i-1]+a[i]; sort(b+1,b+n+1); x=w-b[n];x=min(w,x); y=-b[1];y=max(0,y); if(x-y+1&lt;=0) puts("0"); else printf("%d\n",x-y+1); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 B]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977b%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 B\) 题解： 977B 题意： 给定一个长度为 \(n\) 的字符串 \(s\) ,找到出现次数最多的连续两个字符 ​ 思考： 直接按照题意暴力就好了，没什么好说的 复杂度 \(O(n^2)\) 更新的时候连带位置进行更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long longusing namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn,mn;char s[1010];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n-1;i++) &#123; int flag=1,sum=0; for(register int j=0;j&lt;n-1;j++) if(s[j]!=s[i]||s[j+1]!=s[i+1]) flag=0; else sum++; if(maxn&lt;sum) &#123; maxn=sum; mn=i; &#125; &#125; printf("%c%c\n",s[mn],s[mn+1]); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 A]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978a%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 A\) 题解： 978A 题意： ​ 给定 \(n\) 个整数 ，要求输出数字种类，并且去除重复数字后输出，如果是重复的元素则以最后一次出现的次序完成输出。 ​ 思考： 数据范围 \(a_i\) 很小，只需要开一个 \(rub\) 就好了，记录当前数字是否被访问过，如果没有访问过，记录访问，然后用一个数组记录一下 最后倒序输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn;int a[N],rub[N],c[N],cnt;inline bool cmp(int c,int d)&#123; return c&gt;d;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),maxn=max(maxn,a[i]); for(register int i=n;i&gt;=1;i--) if(!rub[a[i]]) &#123; rub[a[i]]=1; c[++cnt]=a[i]; &#125; printf("%d\n",cnt); for(register int i=cnt;i&gt;=1;i--) printf("%d ",c[i]);puts(""); return 0;&#125; 拓展： 考虑范围很大怎么做 其实也很简单 离散一下数字或者使用 \(map\) 然后就可以按照之前的方法进行处理了]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 B]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978b%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 B\) 题解： 978B 题意： ​ 给出一串字符串，判断里面有对少个连续 $ 3$的 \(“x”\)。注意 \(xxxx\) 里面有两个 \(”xxx“\) ​ 思考： 只需要读入之后，对于每个字符进行识别，如果是 \(x\) 的话，计数器 \(cnt ++\) 否则置零。 然后每次判断是否 $ 3$是的话 $ ans++ $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,cnt,ans;char s[N];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n;i++) &#123; if(s[i]=='x') cnt++; else cnt=0; if(cnt&gt;=3) ans++; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 C]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978c%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 C\) 题解： 978C 题意： ​ ​ \(n\) 个宿舍，每个宿舍有 \(a_i\) 个房间，再给你 \(m\)个数，问每个数在第几个宿舍的第几个房间。 ​ ​ 思考： 读入房间 \(a_i\)之后，我们做一遍前缀和，因为输入保证 \(m\) 个数字保证递增，所以可以边读如边处理，如果小于当前的 \(sum_i\) 继续 $ i++ $ 否则输出就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 200010using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,m,now;ll a[N],sum[N];int main()&#123; n=read(); m=read(); for(register int i=1;i&lt;=n;i++) &#123; a[i]=read(); sum[i]=a[i]+sum[i-1]; &#125; for(register int i=1;i&lt;=m;i++) &#123; ll x=read(); while(x&gt;sum[now]) now++; printf("%d %lld\n",now,x-sum[now-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 D]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978d%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978D\) 题解： 978D 题意： ​ ​ 给 \(n\) 个数字 每个数字可以 \(+1\) \(-1\) 或者 不变，问最少改变几位数字，可以使得 这个 这个序列是单调的，递增或递减或不变 ​ 思考： 读入序列以后，我们考虑最后既然是等差数列，那么公差一定是不变的，也就是可以是 \(a_i - a_{i-1}\) 所以我们只要枚举前两个的改变方式，一共有 \(3*3=9\) 种，然后枚举完公差以后我们可以推出来完整数组，然后和原数组比较，更新答案 一个小细节：就是会出现无法改变成要求的数组，那么我们需要记一下一共无法改变多少次，如果是 \(9\)次的话，输出 \(-1\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 100010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;int n,ans,flag,sum;int a[N],b[N];int main()&#123; n=read(),ans=n; for(register int i=1;i&lt;=n;i++) a[i]=read(); for(register int l=-1;l&lt;=1;l++) for(register int k=-1;k&lt;=1;k++) &#123; b[1]=a[1]+l; b[2]=a[2]+k; int c=b[2]-b[1]; for(register int i=3;i&lt;=n;i++) b[i]=b[i-1]+c; int cnt=0;flag=0; for(register int i=1;i&lt;=n;i++) if(b[i]!=a[i]) &#123; if(abs(b[i]-a[i])&gt;1) &#123; flag=1; sum++; break; &#125; cnt++; &#125; if(!flag) ans=min(ans,cnt); &#125; if(sum!=9) printf("%d\n",ans); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 VP 小结]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978%2F</url>
    <content type="text"><![CDATA[比赛时间 ​ 2019-03-12 08:00～10:30 $ A $ Codeforces 978 a 第一题一句话题意： ​ 给定 \(n​\) 个整数 ，要求输出数字种类，并且去除重复数字后输出，如果是重复的元素则以最后一次出现的次序完成输出。 开场看完直接用rub记一下然后存一下，倒着输出就好了 一遍过 \(B\) Codeforces 978 b 一句话题意： ​ 给出一串字符串，判断里面有对少个连续 $3 的 “x” $，注意 xxxx里面有两个”xxx“ 直接顺着扫一遍，遇到就加，否则清零。中间判一下是否大于等于3就好了 一遍过 \(C\) Codeforces 978 c 一句话题意： ​ \(n\) 个宿舍，每个宿舍有 \(a_i\) 个房间，再给你 \(m\) 个数，问每个数在第几个宿舍的第几个房间。 直接做一下前缀和，因为保证递增（不保证排个序），然后顺着扫一遍就好了 一遍过 \(D\) Codeforces 978 d 一句话题意： ​ 给n个数字 每个数字可以 +1 -1 或者 不变，问最少改变几位数字，可以使得 这个 这个序列是单调的，递增或递减或不变 一开始脑袋抽住了，感觉不会做啊，有点难啊 后来冷静了一下感觉 既然是等差数列，公差相等 然后开始无脑码 又是枚举递增递减，又是枚举公差，又是枚举头尾，写了200+ （自己是真的 \(SB\) ） 太长了 \(pp\) 以后交了 \(WA\) 时间不够了过了 然后看了眼 \(E\) 写完 \(A\) 了以后，回头来看冷静了一下 其实就是枚举一下增量，第一个和第二个分别是哪个操作 然后用公差处理数组，最后更新 \(min\) \(A\) 了 \(E\) Codeforces 978 E 一句话题意： ​ 共 \(N\) 站，汽车每站变化 \(a_i\) 人。问刚开始汽车上人数有多少种可能？ 看完以后直接做了一遍前缀和，然后更新人数最多和最少的时候。最后在区间算一下就好了 然后 就\(Wa\) 了。冷静了一下想了一下细节，没有处理min和max 边界没处理好 最后 \(A\) 了 \(F\) Codeforces 978 F 一句话题意：给出n个人的能力值，给出m对关系，如果一个人的能力值比另一个人的能力值高，并且他们两没有关系的话，那么，这个人就可以成为那个人的导师。求出每个人最多可以是几个人的导师。 直接按照能力排序，找到当前第 \(i\) 个人的能力值 是第几大（不是第几个！！有重复），然后按照关系减一减就好了 过了 \(G\) 没有开，后面看订正篇吧 总结： ​ 1.还是菜的抠脚 ​ 2.时间规划不太对 ​ 3.细节考虑不周全 ​ 4.容易慌乱，代码冗余，思维过于复杂，绕弯子。 \(Over!\)]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作息计划]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%BD%9C%E6%81%AF%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[作息计划 序号 时间 内容 A 06:00 起床 B 06:30 背单词 C 07:30～08:00 整理文件夹&amp;&amp;加题目 D 08:00～10:00 CF VP E 10:00~11:40 学习知识点&amp;&amp;练习 F 12:30～13:00 休息 G 13:00～14:00 练字 H 14:00～15:00 看书 I 15:00～18:00 练习 J 18:00～20:00 文化课 K 20:00～21:00 总结 L 21:00～22:00 锻炼 M 22:00～24:00 练习 N 24:00～01:00 整理总结 执行: 2019-03-04 日期 A B C D E F G H I J K L M N 0304 0305 0306 0307 0308 0309 0310 0311 T T T T T T T F F F T]]></content>
      <categories>
        <category>计划</category>
        <category>作息</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习计划]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[学习计划 上级 学习内容 日期 是否完成 语法 BFS（宽度优先搜索遍历） 3月4日 T 语法 DFS（深度优先搜索遍历） 3月4日 T 语法 记忆化搜索 3月5日 T 语法 简单动态规划 3月6日 T 语法 线性dp 多维dp 树形dp 背包dp 3月7日 3月8日 T 语法 二分答案 3月12日 语法 三分查找 3月12日 数学 快速幂 3月12日 数学 欧拉筛求质数 3月12日 BFS BFS + hash 3月13日 BFS 双向BFS 3月13日 深搜剪枝 最优性剪枝 3月13日 深搜剪枝 可行性剪枝 3月13日 BFS 迭代加深 3月13日 BFS 启发式搜索 3月13日 语法 邻接矩阵 3月14日 最短路径 Dijkstra 3月14日 最短路径 SPFA 3月14日 最短路径 floyd 无向图传递闭包 3月15日 语法 并查集 3月16日 图论 Kruskal 3月16日 图论 Prim 3月16日 图论 拓扑序 3月17日 最短路径 差分约束系统 3月18日 语法 链表思想 领接表 3月19日 字符串 最小表示法 3月20日 字符串 最长回文子串Manacher 3月20日 字符串 Hash 3月20日 数学 矩阵乘法 3月20日 语法 STL 3月21日 树 树的重心 3月22日 树 树的直径 3月22日 简单DP 动态规划 3月23日 位运算 状压dp 3月23日 图论 图的联通性Tarjan（有向图） 3月24日 图论 割点割边点双边双（无向图） 3月25日 图论 LCA（含rmq） 3月26日 图论 2-sat 3月27日 网络流 最大流 3月28日 网络流 费用流 3月29日 数据结构 堆 3月30日 数据结构 树状数组 3月30日 数据结构 线段树 3月31日 线段树 扫描线（先学线段树） 4月1日 常见方法 莫队和树上莫队 4月2日 常见方法 DFS序 4月3日 常见方法 前缀和和差分 4月3日 动态规划 背包9讲 4月4日 动态规划 状态压缩 4月5日 动态规划 单调队列 4月6日 动态规划 四边形不等式 4月7日 动态规划 高级数据结构优化 4月8日 动态规划 斜率优化 4月9日 动态规划 划分数问题 4月10日 搜索 DP其余优化 4月11日 搜索 搜索DLX 4月12日 搜索 整数分块 4月13日 数学 欧几里得 4月14日 数学 扩展欧几里得 乘法逆元 4月14日 数学 高斯消元 4月15日 数学 中国剩余定理 4月16日 数学 大数因式分解pollard-rho 4月17日 数学 大质数判断 Miller-Rabin 4月18日 数学 博弈SG 4月19日 数学 欧拉函数 4月20日 计算几何 点积、叉积 4月21日 计算几何 凸包 4月22日 字符串 KMP 4月22日 字符串 扩展KMP 4月23日 字符串 后缀数组 4月24日 字符串 字母树 4月25日 字符串 AC自动机 4月25日 思维 数点问题 4月26日 思维 块状链表 4月27日 高级数据结构 Treap[传统旋转式] 4月28日 高级数据结构 Treap [非旋转式] 4月28日 高级数据结构 笛卡尔树 4月29日 高级数据结构 左偏树 4月30日 高级数据结构 主席树 5月1日 高级数据结构 Splay 5月2日 高级数据结构 替罪羊树 5月3日 高级数据结构 树链剖分 5月4日 高级数据结构 Link Cut Tree 5月5日 高级数据结构 树套树 5月6日 高级数据结构 整体二分 5月7日 高级数据结构 CDQ分治 5月8日 高级数据结构 可持久化 5月9日 高级数据结构 KDtree 5月10日 高级数据结构 李超线段树 5月11日 树的分治 点分 5月12日 树的分治 边分 5月13日 动态规划 数位动归 5月14日 动态规划 概率期望计数 5月15日 动态规划 插头 5月16日 数学 线性筛求积性函数 5月17日 数学 莫比乌斯反演 5月18日 数学 杜教筛求积性函数前缀和 5月19日 数学 容斥 5月20日 数学 Burnside引理与Polya定理 5月21日 数学 FFT 5月22日 数学 NTT 5月23日 数学 构造 5月24日 数学 组合 5月25日 数学 Simpson 5月26日 数学 线性基 矩阵求逆 常系数线性递推式 5月27日 数学 杨氏矩阵 5月28日 计算几何 半平面交 5月29日 计算几何 旋转卡壳 5月30日 计算几何 凸包合并 5月31日 图论 仙人掌圆方树 图论 最大权闭合子图 图论 单纯形 图论 平面图转对偶图 图论 消圈 字符串 后缀自动机 高级数据结构 Pqtree 高级数据结构 AAATree 高级数据结构 ETT 高级数据结构 TopTree 高级数据结构 动态图连通性 高级数据结构 动态图边双&amp;&amp;点双 高级数据结构 动态平面图判定 树的分治 动态树分治（点分树） 数学 洲阁筛 数学 非质数NTT 数学 非2^n长度fft 数学 多项式求逆元 数学 多项式除法 数学 多项式牛顿迭代（开根） 数学 多点求值 数学 快速插值 计算几何 凸包合并 计算几何 Voronoi Diagrams 计算几何 动态凸包 计算几何 洋葱壳 计算几何 平面图点定位 图论 O(nm)网络流 图论 单纯形 图论 LinkCutCactus 图论 TopCactus 图论 消圈 图论 m^2*logn费用流 图论 多项式复杂度线性规划 字符串 后缀树Ukkonen 字符串 后缀平衡树 字符串 后缀仙人掌]]></content>
      <categories>
        <category>计划</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 VP 小结]]></title>
    <url>%2F2019%2F03%2F11%2Fcf977%2F</url>
    <content type="text"><![CDATA[比赛时间： 2019-03-11 08:00～10:00 $ A $ Codeforces 977 a 开场看 \(A\) 这不是道 \(SB\) 题？ 直接模拟一下就吼了啊！ 写了 1234567891011for(register int i=1;i&lt;=k;i++) &#123; int tmp=n/10; tmp*=10; if(n%tmp!=0) n--; else n/=10; if(n==0) break; &#125; \(ri !\) 连 \(Wa\) 三发 时间到了，算了放在这里，看下一道 $ B $ Codeforces 977 b 开 \(B\) 发现数据很小，直接暴力找就好了 复杂度 $O ( n^2) $ 直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long longusing namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn,mn;char s[1010];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n-1;i++) &#123; int flag=1,sum=0; for(register int j=0;j&lt;n-1;j++) if(s[j]!=s[i]||s[j+1]!=s[i+1]) flag=0; else sum++; if(maxn&lt;sum) &#123; maxn=sum; mn=i; &#125; &#125; printf("%c%c\n",s[mn],s[mn+1]); return 0;&#125; $ C $ Codeforces 977 c 拿到 $ C $以后，想了一下直接 $ Sort $ 一下就好了，然后。。。。。。 就 $ Wa $ 了 然后就跳掉了 $ D $ Codeforces 977 d $ D $ 想了一下 直接将一个数字两次操作后的数字判一下，看是否在数列中，在的话就连边，最后有两个点是只有入变或出边的，最后直接 $ dfs $ 然后写了一发。。。。 又 $ Wa $ 了。。。（长时间不打比赛不太行啊。。。） $ E $ Codeforces 977 e 开了 $ E $ ,的第一个反应直接建个图跑就好了 所有边都连边，记录 \(du_{i}\) 然后 没有访问过的直接dfs判断是否可以就好了 全场第一次最开心。一边交，一遍 $ Ac $ 然后看了一下时间，觉得开 $ F $ ,没什么希望的 回去差错 $ A $ 自己 $ SB $ 直接 $ mod 10$ 就过了 $ C $ 没有考虑 $ k==0 $的情况 如果 \(k==0\) 当前如果 \(a_{1}==1\) 直接 \(puts(&quot;-1&quot;)\) 否则 直接输出 $a_{i}-1$ 就过了 $ D $ 没有开 $ double ​$...... 比赛结束 $AC : A - E $ 总结： 1.缺少练习，比赛经验少 2.考虑情况不全面 3.细节不到位，粗心 $ Over !$]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
