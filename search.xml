<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces 1003 VP 小结]]></title>
    <url>%2F2019%2F03%2F15%2Fcf1003vp%2F</url>
    <content type="text"><![CDATA[不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 比赛时间\(2019-03-15 08:00～10:00\) $ A $ Codeforces 1003 a 一句话题意： 给定 \(n\) 个数字，要求求出至少分成多少子集，可以使得每个组中的元素不重复 （子集中选择的元素可以不连续） 直接暴力找重复数字最多的就好了 \(B\) Codeforces 1003 b 一句话题意：给定三个整数 \(a\) \(b\) \(x\) 要求构造出一个长度为 \(a+b\) 的 \(01\) 串。并且保证 \(s_i != s_{i+1}\) 的数对只有 \(x\) 个 首先我们构造出 \(x-1\) 对不同组，然后再将其次的构造进去就好了 （我觉得这道题考验代码基础的，自己写的有点长，别人的非常短，比较巧妙。订正看吧 $ C $ Codeforces 1003 C 一句话题意：给定 \(n\) 个整数，要求找出区间长度 \(\geq k\)的最大平均数，保留十五位输出 先做一遍前缀和，然后暴力 \(O(n^2)\) 求 \(max\) 就好了 $ D $ Codeforces 1003 D 给定一个数量为 \(n\) 的 \(2^d\) \(2\) 的幂次方集合 \(q\) 次询问 每次询问是否可以由集合中的元素构成 可以输出数量 否则输出\(&quot;-1&quot;\) 考虑其实 \(1e9\) 大小的数最大就到 \(2^32\) 所以可以开一个 \(map\) 记录一下元素的数量每次暴力去做数量就好了 $ E $ Codeforces 1003 E 一句话题意：给定三个整数 \(n\) \(k\) \(d\) 要求构造一颗由 \(n\) 个点，直径为 \(k\) ，最大点度数为 \(d\) 的无向树 先构造出一颗 直径为 \(k\) 的链，然后 \(dfs\) 在链上限制加儿子。 然后处理一下例如 \(d == 1\) 这种特殊情况。 细节想想清就好了 $ F $ Codeforces 1003 F 一句话题意：给定一个由 \(n\) 个单词（字符串）构成的长字符串，单词之间用空格相隔。 现在允许你进行仅一次操作： 对于 两个包含单词个数、长度相同 （\(i , j (i \neq j)\) 长度为 \(k\) 的相同长度），且互不重叠区间。 允许将两段区间中的单词均有首字母组合形成一个新单词。 例如 6 to be or not to be TB or not TB 要求你求出操作后的最短长度 直接先用 \(map\) 离散化一下，然后我们把单词的长度做一个前缀和（不要忘记处理空格的长度） 最后暴力枚举不重叠符合条件区间，更新答案 总结： 思考细节好一点点 2.\(fst\) 概率好像低了一点点 3.速度好了一点 4.继续联系，加快手速 5.多思考如何应该更巧妙的写代码 \(Over !\)]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>1003</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 999 VP 总结]]></title>
    <url>%2F2019%2F03%2F14%2Fcf999vp%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 比赛时间 2019-03-14 08:00～10:00 \(A\) Codeforces 999 A 一句话题意：给定 \(n\) 个整数和一个整数 \(k\) ，可以从左右两端删除 \(\leq k\) 的数字，直到 不可以删除或者全部删除为止 模拟 \(B\) Codeforces 999 B 一句话题意：给定一个长度为 \(n\) 的字符串，每次可以将 \(n\) 的 \(1 ~ 因数\) 的长度 进行字符串反转 要求恢复原串 模拟 \(C\) Codeforces 999 C 一句话题意：给定一个长度为 \(n\) 的字符串，并且给定一个操作次数 \(k\) 操作规则： 对于 \(26\) 个小写 \(a ~ z\) 的字母 按照顺序，如果当前第 \(i\) 个字母存在，则删除最左边的 要求输出执行完毕串 直接先排序 第一关键字字母 第二关键字位置 然后把前 \(k\) 个直接置 \(0\) 最后按照位置排序 输出 模拟 \(D\) Codeforces 999 D 一句话题意：给定一个长度为 \(n\) 的整数序列和一个 \(m\) 每次操作可以使一个数 \(+1\) ，要求对于所有数字 %mod m% 之后得到 \(0 ~ m-1\) 个余数的个数都是 \(\frac{n}{m}\) 个 要求输出最简操作数，和操作后的序列 考场没 \(A\) 只想到了贪心数量怎么求，序列不会 考试结束以后冷静一下，只要二分就好了，按照贪心模拟加 解法看订正吧 \(E\) Codeforces 999 E 一句话题意：给定 \(n\) 个点，\(m\) 条 单向边 和一个源点 \(s\) 要求求出需要加多少条边可以使得每个点都可以到达源点 直接强连通缩点，感觉有点板题 \(F\) Codeforces 999 F 一句话题意： 有 \(n\) 个人 \(n∗k\) 张卡片，每个人都要分到 \(k\) 张卡片。 卡片上有数字，每个人也有一个数字，当一个人分到 \(i\) 张和他的数字一样的卡片时会有 \(h_i\) 的贡献 求最大贡献。 明显的 \(DP\) 题解看订正]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>999</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典-第六章]]></title>
    <url>%2F2019%2F03%2F13%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-6%2F</url>
    <content type="text"><![CDATA[不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！]]></content>
      <categories>
        <category>Book</category>
        <category>算法竞赛入门经典</category>
        <category>第二部分——基础篇</category>
        <category>第六章——数据结构基础</category>
        <category>6.1</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 988 VP 小结]]></title>
    <url>%2F2019%2F03%2F13%2Fcf977vp%2F</url>
    <content type="text"><![CDATA[不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 比赛时间 \(2019-03-13\) \(08:00～10:00\) \(A\) Codeforces988A 一句话题意：给定 \(n\) 个数 问是否存在 \(k\) 个不同的数，如果存在输出这 \(k\) 个数的下标 否则输出 \(NO\) 直接模拟判一下就好了 一次 \(A\) \(B\) Codeforces988B 一句话题意：给定 \(n\) 个字符串 问是否可以重新排列使每个字符串是前一个的子串 如果可以输出 \(YES\) 并且输出排列 否则输出\(NO\) 考虑子串的长度一定 \(\leq\) 原串的长度。所以直接按照长度排序 然后暴力判断是否是子串就好了 一次\(A\) \(C\) Codeforces988C 一句话题意：给定 \(n\) 个数组，问是否存在两个不同数组，任意删去一个数字后，加和相同 这道题单纯的考 \(STL\) 的应用 （我最菜的地方） 其实冷静一下很好做 用 \(Vector\) 存一下数组，然后用\(map\) 存一下当前的加和 然后暴力判断一下就好了 就是不知道为什么 \(fst\) 了。。。。 看订正吧。。。。。 \(D\) Codeforces988D 一句话题意：给定一个整数集合，要求你找出一个最大的子集，使得子集内的任意两两整数差为 \(2\) 的幂次 不要被题意和巨大的数据范围骗了 冷静一下其实可以发现子集最大也就三个 （证明看订正 所以我们可以枚举\(2\)的幂次 然后找到三个公差等于该数的就好了 \(E\) Codeforces988E 一句话题意：给定一个 \(11e18 \leq x \leq 1e18\) 的数字 。 要求判断是否可以通过交换相邻位置的数字使得数字可以被25整除 其实就是一个小细节的模拟 \(25\) 的倍数的后缀 分别是 \(00 25 75 50\) 四种情况，所以每次拿四种情况更新一下答案就好了 一定要注意含有前导\(0\) 的情况 \(F\) Codeforces988F 考试没开，今天菜的一批（凸显了自己 \(STL\) 差的问题 暴露的很及时） 一句话题意： 有三个整数 \(a,n,m\)，\(a\) 是终点坐标，给出 \(n\) 个范围（\(l,r\)）表示这块区域下雨，\(m\) 把伞(\(p,w\) )在点 \(p\) 有重量为 \(w\) 的伞。 小明可以携带任意数量的伞，经过下雨处时必须要撑伞，小明每走一个单位长度消耗的体力与他所携带伞的重量相同， 求小明从 \(0~a\)所需消耗的最少体力，若无解则输出 \(-1\)。 一眼看的 \(DP\) 具体做法看订正 总结： \(STL\) 掌握的太差了，要多加练习 细节考虑稍好了一点点 速度应该再快一点，继续提高代码能力，减少 \(FST\) 的概率 \(Over !\)]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>988</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 E]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978E%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978E\) 题解： 978E 题意： ​ ​ ​共 \(N\) 站，汽车每站变化 \(a_i\) 人。问刚开始汽车上人数有多少种可能？ ​ 思考： 因为是变化值，所以相当于差分了一下，先做一遍前缀和，变成每个车站当前有多少人。然后排序前缀和数组。\(- sum_1\) 就是最少的人数边界 \(w - sum_n\) 就是最多的人数边界 最 \(ans\) 就是两者相减 注意： 做处理的时候有可能是单调，也就是说一直下车或者一直上车 最小边界要做处理： \(minn=max(-sum_i , 0)\) 最大边界要做处理： \(maxn=minn(w,w-sum[n])\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,x,y,ans,w;int a[N],b[N];int main()&#123; n=read(); w=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),b[i]=b[i-1]+a[i]; sort(b+1,b+n+1); x=w-b[n];x=min(w,x); y=-b[1];y=max(0,y); if(x-y+1&lt;=0) puts("0"); else printf("%d\n",x-y+1); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>思维</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 E]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977e%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 E\) 题解： 977E 题意： ​​找到所有的单链环的个数 ​ ​ 思考： 很明显，一个单链环中的所有节点的 度都为\(2\) 所以直接对于整个图的点 \(dfs\) 然后判一下边界就好了 不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define ll long long#define N 200010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,m,cnt,ans,flag;int vis[N],du[N],hed[N];structt st&#123; int to,nxt;&#125;edge[N&lt;&lt;1];inline void add(int x,int y)&#123; cnt++; edge[cnt].to=y; edge[cnt].nxt=hed[x]; hed[x]=cnt;&#125;inline void dfs(int x,int t,int fa)&#123; if(vis[x]==1||du[x]!=2) &#123; flag=0; return ; &#125; vis[x]=1; if(flag) return; for(register int i=hed[x];i;i=edge[i].nxt) &#123; int v=edge[i].to; if(v==fa) continue; if(v==t) &#123; flag=1; return ; &#125; if(flag) return ; dfs(v,t,x); &#125; return ;&#125;int main()&#123; n=read(); m=read(); for(register int i=1;i&lt;=m;i++) &#123; int x,y; x=read(); y=read(); du[y]++,du[x]++; add(x,y); add(y,x); &#125; for(register int i=1;i&lt;=n;i++) if(du[i]==2&amp;&amp;vis[i]==0) &#123; flag=0; dfs(i,i,i); ans+=flag; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 F]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977f%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 F\) 题解： 977F 题意： 给出一个 \(n\) 和 \(n\) 个数的序列，然后让你找到满足两个数之间相差为 \(1\) 的存在的最长的序列。 要求输出他们的下标。 ​ 思考： 因为数据 \(a_i\) 的范围很大，首先可以想到用 \(map\) 进行离散化和存储 所以 \(map_i\) 表示当前以 \(i\) 这个数字结尾的最长序列长度 （有点像最长上升子序列的 \(O(nlogn)\)的做法） 然后更新一下答案就好了 不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;map&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 200010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,cnt,en,ans;map&lt;int,int&gt;m;int num[N];int p[N];int main()&#123; n=read(); for(register int i=1;i&lt;=n;i++) &#123; num[i]=read(); m[num[i]]=max(m[num[i]],m[num[i]-1]+1); if(m[num[i]]&gt;ans) &#123; ans=m[num[i]]; en=num[i]; &#125; &#125; for(register int i=n;i&gt;=1;i--) if(num[i]==en) &#123; p[++cnt]=i; en--; &#125; printf("%d\n",cnt); for(register int i=cnt;i&gt;=1;i--) printf("%d ",p[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学引论-绪论]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%BC%95%E8%AE%BA-%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[组合数学引论 绪论 组合数学用于解决生活中的组合问题 又称组合学、组合分析 问题分类（共有四种） 一、 存在性问题（安排存在性问题） 应用于解决在有限个对象中按照满足要求的条件性质进行安排。 符合要求的安排与否。需要通过组合数学证明是否存在 二、计数类问题 （安排的枚举和分类） 在基于上一种问题的存在情况之后。会需要解决有多少种安排存在的情况 有多少种可能的安排方案？ 如何对安排进行分类 三、构造性问题 基于前两种问题之上 已经确定该问题具有存在方案后，要求根据方案具体的给出一种符合题意的安排，符合条件。 也就是需要给出求其某一特定的解的 算法 四、优化类问题 在问题二成立的情况下，不同分配方案附带的消耗或者收益是不同的 所以在实际应用中，需要在全部存在方案中找到最优或近乎最优的安排方案 算法]]></content>
      <categories>
        <category>Book</category>
        <category>组合数学引论</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Book</tag>
        <tag>学习</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 A]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977a%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 A\) 题解： 977A 题意： 给定一个整数 \(n\) 然后给定一个操作次数 \(k\) ,要求输出最后根据操作的数字 操作如下： 当最后一位不为\(0\) 则减 \(1\) 否则除 \(10\) ​ 思考： 直接按照题意模拟就好了，没什么好说的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;ll n,k;int main()&#123; n=read(); k=read(); for(register int i=1;i&lt;=k;i++) &#123; if(n%10!=0) n--; else n/=10; &#125; printf("%lld\n",n); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 B]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977b%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 B\) 题解： 977B 题意： 给定一个长度为 \(n\) 的字符串 \(s\) ,找到出现次数最多的连续两个字符 ​ 思考： 直接按照题意暴力就好了，没什么好说的 复杂度 \(O(n^2)\) 更新的时候连带位置进行更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long longusing namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn,mn;char s[1010];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n-1;i++) &#123; int flag=1,sum=0; for(register int j=0;j&lt;n-1;j++) if(s[j]!=s[i]||s[j+1]!=s[i+1]) flag=0; else sum++; if(maxn&lt;sum) &#123; maxn=sum; mn=i; &#125; &#125; printf("%c%c\n",s[mn],s[mn+1]); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977d%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 D\) 题解： 977D 题意： 给你一个被打乱的序列，每次操作，都要把这个数除以 \(3\) 或者乘 \(2\) ， 使之变成下一个数，输出排序后满足条件的原序列数。 ​ 思考： 我们分析一下其实这个给定数组中的每一个数字都是 \(3\) 的幂次与 \(2\) 的幂次的加和 所以我们需要重新排序 第一关键词，首先按照一个数字能够整除 \(3\) 的次数，这显然是一个递减序列 如果次数相同时，那么只有乘 \(2\) 的变大操作 ，所以此时把较大的放到后面 就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 110using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n;ll a[N];inline ll get(ll x)&#123; ll cnt=0; while((x%3)==0) &#123; cnt++; x/=3; &#125; return cnt;&#125;inline bool cmp(ll x,ll y)&#123; ll tmp1,tmp2; tmp1=get(x); tmp2=get(y); if(tmp1==tmp2) return x&lt;y; return tmp1&gt;tmp2;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1,cmp); for(register int i=1;i&lt;=n;i++) printf("%lld ",a[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 A]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978a%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 A\) 题解： 978A 题意： ​ 给定 \(n\) 个整数 ，要求输出数字种类，并且去除重复数字后输出，如果是重复的元素则以最后一次出现的次序完成输出。 ​ 思考： 数据范围 \(a_i\) 很小，只需要开一个 \(rub\) 就好了，记录当前数字是否被访问过，如果没有访问过，记录访问，然后用一个数组记录一下 最后倒序输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn;int a[N],rub[N],c[N],cnt;inline bool cmp(int c,int d)&#123; return c&gt;d;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),maxn=max(maxn,a[i]); for(register int i=n;i&gt;=1;i--) if(!rub[a[i]]) &#123; rub[a[i]]=1; c[++cnt]=a[i]; &#125; printf("%d\n",cnt); for(register int i=cnt;i&gt;=1;i--) printf("%d ",c[i]);puts(""); return 0;&#125; 拓展： 考虑范围很大怎么做 其实也很简单 离散一下数字或者使用 \(map\) 然后就可以按照之前的方法进行处理了]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 B]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978b%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 B\) 题解： 978B 题意： ​ 给出一串字符串，判断里面有对少个连续 $ 3$的 \(“x”\)。注意 \(xxxx\) 里面有两个 \(”xxx“\) ​ 思考： 只需要读入之后，对于每个字符进行识别，如果是 \(x\) 的话，计数器 \(cnt ++\) 否则置零。 然后每次判断是否 $ 3$是的话 $ ans++ $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,cnt,ans;char s[N];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n;i++) &#123; if(s[i]=='x') cnt++; else cnt=0; if(cnt&gt;=3) ans++; &#125; printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 C]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978c%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 C\) 题解： 978C 题意： ​ ​ \(n\) 个宿舍，每个宿舍有 \(a_i\) 个房间，再给你 \(m\)个数，问每个数在第几个宿舍的第几个房间。 ​ ​ 思考： 读入房间 \(a_i\)之后，我们做一遍前缀和，因为输入保证 \(m\) 个数字保证递增，所以可以边读如边处理，如果小于当前的 \(sum_i\) 继续 $ i++ $ 否则输出就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 200010using namespace std;inline ll read()&#123; register ll x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,m,now;ll a[N],sum[N];int main()&#123; n=read(); m=read(); for(register int i=1;i&lt;=n;i++) &#123; a[i]=read(); sum[i]=a[i]+sum[i-1]; &#125; for(register int i=1;i&lt;=m;i++) &#123; ll x=read(); while(x&gt;sum[now]) now++; printf("%d %lld\n",now,x-sum[now-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 D]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978d%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978D\) 题解： 978D 题意： ​ ​ 给 \(n\) 个数字 每个数字可以 \(+1\) \(-1\) 或者 不变，问最少改变几位数字，可以使得 这个 这个序列是单调的，递增或递减或不变 ​ 思考： 读入序列以后，我们考虑最后既然是等差数列，那么公差一定是不变的，也就是可以是 \(a_i - a_{i-1}\) 所以我们只要枚举前两个的改变方式，一共有 \(3*3=9\) 种，然后枚举完公差以后我们可以推出来完整数组，然后和原数组比较，更新答案 一个小细节：就是会出现无法改变成要求的数组，那么我们需要记一下一共无法改变多少次，如果是 \(9\)次的话，输出 \(-1\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 100010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;int n,ans,flag,sum;int a[N],b[N];int main()&#123; n=read(),ans=n; for(register int i=1;i&lt;=n;i++) a[i]=read(); for(register int l=-1;l&lt;=1;l++) for(register int k=-1;k&lt;=1;k++) &#123; b[1]=a[1]+l; b[2]=a[2]+k; int c=b[2]-b[1]; for(register int i=3;i&lt;=n;i++) b[i]=b[i-1]+c; int cnt=0;flag=0; for(register int i=1;i&lt;=n;i++) if(b[i]!=a[i]) &#123; if(abs(b[i]-a[i])&gt;1) &#123; flag=1; sum++; break; &#125; cnt++; &#125; if(!flag) ans=min(ans,cnt); &#125; if(sum!=9) printf("%d\n",ans); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>思维</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 G]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978g%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978 G\) 题解： 978G 题意： ​共有 \(n\) 天，\(m\) 场考试编号 \(1～m\) ，每场考试给出 \(s\) 题库发布的时间（即代表从此时起可以开始复习这门科目） \(d\) 这门科目考试的时间 \(t\) 需要复习的时间。 现在，每天你可以选择复习，或者休息，只能选其中一样！如果是考试的时间，则必须去考试！ 问，你是否可以复习完所有科目并通过考试 如果可以，输出安排表，\(1～m\) 代表复习功课，\(0\) 表示休息，\(m+1\) 表示考试。 如果不能，输出 \(-1\)。 ​ 思考： 显然是一道贪心，考试时间越早的我们要越早复习完。 所以开一个 \(struct\) 记录发布时间，考试时间，复习时间，和考试编号 然后对于一天我们就暴力去判断 考试的天必须考试 剩下的根据题目限制判断一下复习还是休息 最后，如果有的科目没有复习完则不合法，否则允许 注意：题目没有要求连续复习，所以允许隔天复习！！！ 不知道为什么我的代码\(struct\) 会导致hexo 报错，所以代码有 \(bug\)，谅解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a.b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 110using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,m,flag;structt st&#123; int id,s,e,t;&#125;a[N];int ans[N];inline bool cmp(st x,st y)&#123; return x.t&lt;y.t;&#125;int main()&#123; n=read(); m=read(); for(register int i=1;i&lt;=m;i++) &#123; a[i].id=i; a[i].s=read(); a[i].t=read(); a[i].e=read(); ans[a[i].t]=m+1; &#125; sort(a+1,a+m+1,cmp); for(register int i=1;i&lt;=n;i++) &#123; if(ans[i]) continue; flag=0; for(register int j=1;j&lt;=m;j++) &#123; if((a[j].e)&amp;&amp;(a[j].s&lt;=i)&amp;&amp;(a[j].t&gt;i)) &#123; ans[i]=a[j].id; a[j].e--; flag=1; &#125; if(flag) break; &#125; &#125; for(register int j=1;j&lt;=m;j++) if(a[j].e) &#123; puts("-1"); return 0; &#125; for(register int i=1;i&lt;=n;i++) printf("%d ",ans[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 C]]></title>
    <url>%2F2019%2F03%2F12%2Fcf977c%2F</url>
    <content type="text"><![CDATA[\(Codeforces 977 C\) 题解： 977C 题意： 给你一个长度为 \(n\) 的整数序列和一个数 \(k\) 。 您应该在 \([1 , 1e9]\)（即 $1 x 1e9 $）的范围内输出任何整数 \(x\)，使得给定序列的 \(k\) 个元素恰好小于或等于x。 请注意，该序列可以包含相同的元素。 如果没有这样的\(x\)，则输出 \(“-1”\)（不含引号） ​ 思考： 直接进行排序，然后吧第 \(k\) 的元素输出 然后你就会发现 \(Wa\) 了 少了一种情况 如果 \(k==0\) 时，而当前 \(a_1\) 却等于 \(1\) 你会发现其实是没有数字满足要求的 所以还要特判一下 \(k==0\) 的情况就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 2000100using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,k;int a[N];int main()&#123; n=read(); k=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1); int tmp=a[k],sum=0; for(register int i=1;i&lt;=n;i++) if(tmp&gt;=a[i]) sum++; if(k==0) &#123; if(a[1]==1) puts("-1"); else printf("%d\n",a[1]-1); return 0; &#125; if(sum==k) printf("%d\n",tmp); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>lv0</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 F]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978F%2F</url>
    <content type="text"><![CDATA[\(Codeforces 978F\) 题解： 978F 题意： ​ ​ 给出 \(n\) 个人的能力值，给出 \(m\) 对关系，如果一个人的能力值比另一个人的能力值高，并且他们两没有关系的话，那么，这个人就可以成为那个人的导师。求出每个人最多可以是几个人的导师。 ​ 思考： 开一个 \(struct\) 记录当前这个人的 位置、能力值、答案 然后按照能力值从小到大排序。排序之后按照二分出当前的能量值是第几大的能力值，更新答案。 处理关系，每次输进来，在较大的一个能力值中减掉一个就好了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long long#define N 1010using namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,x,y,ans,w;int a[N],b[N];int main()&#123; n=read(); w=read(); for(register int i=1;i&lt;=n;i++) a[i]=read(),b[i]=b[i-1]+a[i]; sort(b+1,b+n+1); x=w-b[n];x=min(w,x); y=-b[1];y=max(0,y); if(x-y+1&lt;=0) puts("0"); else printf("%d\n",x-y+1); return 0;&#125;]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>lv0</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 978 VP 小结]]></title>
    <url>%2F2019%2F03%2F12%2Fcf978%2F</url>
    <content type="text"><![CDATA[比赛时间 ​ 2019-03-12 08:00～10:30 $ A $ Codeforces 978 a 第一题一句话题意： ​ 给定 \(n​\) 个整数 ，要求输出数字种类，并且去除重复数字后输出，如果是重复的元素则以最后一次出现的次序完成输出。 开场看完直接用rub记一下然后存一下，倒着输出就好了 一遍过 \(B\) Codeforces 978 b 一句话题意： ​ 给出一串字符串，判断里面有对少个连续 $3 的 “x” $，注意 xxxx里面有两个”xxx“ 直接顺着扫一遍，遇到就加，否则清零。中间判一下是否大于等于3就好了 一遍过 \(C\) Codeforces 978 c 一句话题意： ​ \(n\) 个宿舍，每个宿舍有 \(a_i\) 个房间，再给你 \(m\) 个数，问每个数在第几个宿舍的第几个房间。 直接做一下前缀和，因为保证递增（不保证排个序），然后顺着扫一遍就好了 一遍过 \(D\) Codeforces 978 d 一句话题意： ​ 给n个数字 每个数字可以 +1 -1 或者 不变，问最少改变几位数字，可以使得 这个 这个序列是单调的，递增或递减或不变 一开始脑袋抽住了，感觉不会做啊，有点难啊 后来冷静了一下感觉 既然是等差数列，公差相等 然后开始无脑码 又是枚举递增递减，又是枚举公差，又是枚举头尾，写了200+ （自己是真的 \(SB\) ） 太长了 \(pp\) 以后交了 \(WA\) 时间不够了过了 然后看了眼 \(E\) 写完 \(A\) 了以后，回头来看冷静了一下 其实就是枚举一下增量，第一个和第二个分别是哪个操作 然后用公差处理数组，最后更新 \(min\) \(A\) 了 \(E\) Codeforces 978 E 一句话题意： ​ 共 \(N\) 站，汽车每站变化 \(a_i\) 人。问刚开始汽车上人数有多少种可能？ 看完以后直接做了一遍前缀和，然后更新人数最多和最少的时候。最后在区间算一下就好了 然后 就\(Wa\) 了。冷静了一下想了一下细节，没有处理min和max 边界没处理好 最后 \(A\) 了 \(F\) Codeforces 978 F 一句话题意：给出n个人的能力值，给出m对关系，如果一个人的能力值比另一个人的能力值高，并且他们两没有关系的话，那么，这个人就可以成为那个人的导师。求出每个人最多可以是几个人的导师。 直接按照能力排序，找到当前第 \(i\) 个人的能力值 是第几大（不是第几个！！有重复），然后按照关系减一减就好了 过了 \(G\) 没有开，后面看订正篇吧 总结： ​ 1.还是菜的抠脚 ​ 2.时间规划不太对 ​ 3.细节考虑不周全 ​ 4.容易慌乱，代码冗余，思维过于复杂，绕弯子。 \(Over!\)]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>978</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作息计划]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%BD%9C%E6%81%AF%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[作息计划 序号 时间 内容 A 06:00 起床 B 06:30 背单词 C 07:30～08:00 整理文件夹&amp;&amp;加题目 D 08:00～10:00 CF VP E 10:00~11:40 学习知识点&amp;&amp;练习 F 12:30～13:00 休息 G 13:00～14:00 练字 H 14:00～15:00 看书 I 15:00～18:00 练习 J 18:00～20:00 文化课 K 20:00～21:00 总结 L 21:00～22:00 锻炼 M 22:00～24:00 练习 N 24:00～01:00 整理总结 执行: 2019-03-04 一周一次 \(Update\) 日期 A B C D E F G H I J K L M N 0304 0305 0306 0307 0308 0309 0310 0311 T T T T T T T F F F T]]></content>
      <categories>
        <category>计划</category>
        <category>作息</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习计划]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[学习计划 上级 学习内容 日期 是否完成 语法 BFS（宽度优先搜索遍历） 3月4日 T 语法 DFS（深度优先搜索遍历） 3月4日 T 语法 记忆化搜索 3月5日 T 语法 简单动态规划 3月6日 T 语法 线性dp 多维dp 树形dp 背包dp 3月7日 3月8日 T 语法 二分答案 3月12日 语法 三分查找 3月12日 数学 快速幂 3月12日 数学 欧拉筛求质数 3月12日 BFS BFS + hash 3月13日 BFS 双向BFS 3月13日 深搜剪枝 最优性剪枝 3月13日 深搜剪枝 可行性剪枝 3月13日 BFS 迭代加深 3月13日 BFS 启发式搜索 3月13日 语法 邻接矩阵 3月14日 最短路径 Dijkstra 3月14日 最短路径 SPFA 3月14日 最短路径 floyd 无向图传递闭包 3月15日 语法 并查集 3月16日 图论 Kruskal 3月16日 图论 Prim 3月16日 图论 拓扑序 3月17日 最短路径 差分约束系统 3月18日 语法 链表思想 领接表 3月19日 字符串 最小表示法 3月20日 字符串 最长回文子串Manacher 3月20日 字符串 Hash 3月20日 数学 矩阵乘法 3月20日 语法 STL 3月21日 树 树的重心 3月22日 树 树的直径 3月22日 简单DP 动态规划 3月23日 位运算 状压dp 3月23日 图论 图的联通性Tarjan（有向图） 3月24日 图论 割点割边点双边双（无向图） 3月25日 图论 LCA（含rmq） 3月26日 图论 2-sat 3月27日 网络流 最大流 3月28日 网络流 费用流 3月29日 数据结构 堆 3月30日 数据结构 树状数组 3月30日 数据结构 线段树 3月31日 线段树 扫描线（先学线段树） 4月1日 常见方法 莫队和树上莫队 4月2日 常见方法 DFS序 4月3日 常见方法 前缀和和差分 4月3日 动态规划 背包9讲 4月4日 动态规划 状态压缩 4月5日 动态规划 单调队列 4月6日 动态规划 四边形不等式 4月7日 动态规划 高级数据结构优化 4月8日 动态规划 斜率优化 4月9日 动态规划 划分数问题 4月10日 搜索 DP其余优化 4月11日 搜索 搜索DLX 4月12日 搜索 整数分块 4月13日 数学 欧几里得 4月14日 数学 扩展欧几里得 乘法逆元 4月14日 数学 高斯消元 4月15日 数学 中国剩余定理 4月16日 数学 大数因式分解pollard-rho 4月17日 数学 大质数判断 Miller-Rabin 4月18日 数学 博弈SG 4月19日 数学 欧拉函数 4月20日 计算几何 点积、叉积 4月21日 计算几何 凸包 4月22日 字符串 KMP 4月22日 字符串 扩展KMP 4月23日 字符串 后缀数组 4月24日 字符串 字母树 4月25日 字符串 AC自动机 4月25日 思维 数点问题 4月26日 思维 块状链表 4月27日 高级数据结构 Treap[传统旋转式] 4月28日 高级数据结构 Treap [非旋转式] 4月28日 高级数据结构 笛卡尔树 4月29日 高级数据结构 左偏树 4月30日 高级数据结构 主席树 5月1日 高级数据结构 Splay 5月2日 高级数据结构 替罪羊树 5月3日 高级数据结构 树链剖分 5月4日 高级数据结构 Link Cut Tree 5月5日 高级数据结构 树套树 5月6日 高级数据结构 整体二分 5月7日 高级数据结构 CDQ分治 5月8日 高级数据结构 可持久化 5月9日 高级数据结构 KDtree 5月10日 高级数据结构 李超线段树 5月11日 树的分治 点分 5月12日 树的分治 边分 5月13日 动态规划 数位动归 5月14日 动态规划 概率期望计数 5月15日 动态规划 插头 5月16日 数学 线性筛求积性函数 5月17日 数学 莫比乌斯反演 5月18日 数学 杜教筛求积性函数前缀和 5月19日 数学 容斥 5月20日 数学 Burnside引理与Polya定理 5月21日 数学 FFT 5月22日 数学 NTT 5月23日 数学 构造 5月24日 数学 组合 5月25日 数学 Simpson 5月26日 数学 线性基 矩阵求逆 常系数线性递推式 5月27日 数学 杨氏矩阵 5月28日 计算几何 半平面交 5月29日 计算几何 旋转卡壳 5月30日 计算几何 凸包合并 5月31日 图论 仙人掌圆方树 图论 最大权闭合子图 图论 单纯形 图论 平面图转对偶图 图论 消圈 字符串 后缀自动机 高级数据结构 Pqtree 高级数据结构 AAATree 高级数据结构 ETT 高级数据结构 TopTree 高级数据结构 动态图连通性 高级数据结构 动态图边双&amp;&amp;点双 高级数据结构 动态平面图判定 树的分治 动态树分治（点分树） 数学 洲阁筛 数学 非质数NTT 数学 非2^n长度fft 数学 多项式求逆元 数学 多项式除法 数学 多项式牛顿迭代（开根） 数学 多点求值 数学 快速插值 计算几何 凸包合并 计算几何 Voronoi Diagrams 计算几何 动态凸包 计算几何 洋葱壳 计算几何 平面图点定位 图论 O(nm)网络流 图论 单纯形 图论 LinkCutCactus 图论 TopCactus 图论 消圈 图论 m^2*logn费用流 图论 多项式复杂度线性规划 字符串 后缀树Ukkonen 字符串 后缀平衡树 字符串 后缀仙人掌]]></content>
      <categories>
        <category>计划</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 977 VP 小结]]></title>
    <url>%2F2019%2F03%2F11%2Fcf977%2F</url>
    <content type="text"><![CDATA[比赛时间： 2019-03-11 08:00～10:00 $ A $ Codeforces 977 a 开场看 \(A\) 这不是道 \(SB\) 题？ 直接模拟一下就吼了啊！ 写了 1234567891011for(register int i=1;i&lt;=k;i++) &#123; int tmp=n/10; tmp*=10; if(n%tmp!=0) n--; else n/=10; if(n==0) break; &#125; \(ri !\) 连 \(Wa\) 三发 时间到了，算了放在这里，看下一道 $ B $ Codeforces 977 b 开 \(B\) 发现数据很小，直接暴力找就好了 复杂度 $O ( n^2) $ 直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#define maX(a,b) (a&gt;b?a:b)#define miN(a,b) (a&lt;b?a:b)#define ll long longusing namespace std;inline int read()&#123; register int x=0; register bool f=0; register char ch=getchar(); while(!isdigit(ch)) &#123; f^=!(ch^'-'); ch=getchar(); &#125; while(isdigit(ch)) &#123; x=((x+(x&lt;&lt;2))&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return f?-x:x;&#125;inline void print(int x)&#123; register int sc[30]=&#123;0&#125;,tot=0; do &#123; sc[++tot]=x%10; x/=10; &#125;while(x); while(tot) putchar('0'+sc[tot--]);&#125;int n,maxn,mn;char s[1010];int main()&#123; n=read(); scanf("%s",s); for(register int i=0;i&lt;n-1;i++) &#123; int flag=1,sum=0; for(register int j=0;j&lt;n-1;j++) if(s[j]!=s[i]||s[j+1]!=s[i+1]) flag=0; else sum++; if(maxn&lt;sum) &#123; maxn=sum; mn=i; &#125; &#125; printf("%c%c\n",s[mn],s[mn+1]); return 0;&#125; $ C $ Codeforces 977 c 拿到 $ C $以后，想了一下直接 $ Sort $ 一下就好了，然后。。。。。。 就 $ Wa $ 了 然后就跳掉了 $ D $ Codeforces 977 d $ D $ 想了一下 直接将一个数字两次操作后的数字判一下，看是否在数列中，在的话就连边，最后有两个点是只有入变或出边的，最后直接 $ dfs $ 然后写了一发。。。。 又 $ Wa $ 了。。。（长时间不打比赛不太行啊。。。） $ E $ Codeforces 977 e 开了 $ E $ ,的第一个反应直接建个图跑就好了 所有边都连边，记录 \(du_{i}\) 然后 没有访问过的直接dfs判断是否可以就好了 全场第一次最开心。一边交，一遍 $ Ac $ 然后看了一下时间，觉得开 $ F $ ,没什么希望的 回去差错 $ A $ 自己 $ SB $ 直接 $ mod 10$ 就过了 $ C $ 没有考虑 $ k==0 $的情况 如果 \(k==0\) 当前如果 \(a_{1}==1\) 直接 \(puts(&quot;-1&quot;)\) 否则 直接输出 $a_{i}-1$ 就过了 $ D $ 没有开 $ double ​$...... 比赛结束 $AC : A - E $ 总结： 1.缺少练习，比赛经验少 2.考虑情况不全面 3.细节不到位，粗心 $ Over !$]]></content>
      <categories>
        <category>Contest</category>
        <category>Codeforces</category>
        <category>977</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
